<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractCopyEventsByDate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">calendar</a> &gt; <a href="index.source.html" class="el_package">calendar.strategy</a> &gt; <span class="el_source">AbstractCopyEventsByDate.java</span></div><h1>AbstractCopyEventsByDate.java</h1><pre class="source lang-java linenums">package calendar.strategy;

import static calendar.util.EditEvent.validateNoDuplicate;

import calendar.dto.CopyEventDto;
import calendar.interfacetypes.Icopy;
import calendar.model.Calendar;
import calendar.model.Event;
import calendar.model.EventBuilder;
import java.time.Duration;
import java.time.LocalDate;
import java.time.ZonedDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Abstract template for copying multiple events based on date criteria.
 * Implements the common algorithm for copying events within a date range,
 * leaving the event-selection and target date calculation to subclasses.
 */
<span class="fc" id="L28">public abstract class AbstractCopyEventsByDate implements Icopy {</span>

  @Override
  public Set&lt;Event&gt; copy(CopyEventDto dto, Calendar sourceCalendar, Calendar targetCalendar)
      throws Exception {
<span class="fc" id="L33">    List&lt;Event&gt; eventsToCopy = getEventsInDateRange(dto, sourceCalendar);</span>
<span class="fc bfc" id="L34" title="All 2 branches covered.">    if (eventsToCopy.isEmpty()) {</span>
<span class="fc" id="L35">      throw new Exception(getNoEventsFoundMessage(dto));</span>
    }
<span class="fc" id="L37">    eventsToCopy = eventsToCopy.stream()</span>
<span class="fc" id="L38">        .sorted(Comparator.comparing(Event::getStartDateTime))</span>
<span class="fc" id="L39">        .collect(Collectors.toList());</span>
<span class="fc" id="L40">    LocalDate firstEventDate = eventsToCopy.get(0).getStartDateTime().toLocalDate();</span>
<span class="fc" id="L41">    LocalDate targetDate = calculateTargetDate(dto, firstEventDate);</span>
<span class="fc" id="L42">    long daysBetween = ChronoUnit.DAYS.between(firstEventDate, targetDate);</span>
<span class="fc" id="L43">    return copyEventsWithOffset(eventsToCopy, daysBetween, targetCalendar);</span>
  }

  /**
   * Copies all events by shifting them by the specified number of days.
   * Maintains series relationships and validates against duplicates.
   */
  private Set&lt;Event&gt; copyEventsWithOffset(List&lt;Event&gt; eventsToCopy,
                                          long daysBetween,
                                          Calendar targetCalendar) throws Exception {
<span class="fc" id="L53">    Set&lt;Event&gt; newEvents = new HashSet&lt;&gt;();</span>
<span class="fc" id="L54">    Set&lt;Event&gt; eventsToRemove = new HashSet&lt;&gt;();</span>
<span class="fc" id="L55">    Map&lt;String, String&gt; seriesIdMapping = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">    for (Event sourceEvent : eventsToCopy) {</span>
<span class="fc" id="L57">      ZonedDateTime newStart = sourceEvent.getStartDateTime()</span>
<span class="fc" id="L58">          .plusDays(daysBetween)</span>
<span class="fc" id="L59">          .withZoneSameInstant(targetCalendar.getTimezone());</span>
<span class="fc" id="L60">      Duration eventDuration = Duration.between(</span>
<span class="fc" id="L61">          sourceEvent.getStartDateTime(),</span>
<span class="fc" id="L62">          sourceEvent.getEndDateTime());</span>
<span class="fc" id="L63">      ZonedDateTime newEnd = newStart.plus(eventDuration);</span>
<span class="pc bpc" id="L64" title="1 of 4 branches missed.">      if (sourceEvent.getSeriesId() != null &amp;&amp; !sourceEvent.getSeriesId().isEmpty()</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">          &amp;&amp; !newStart.toLocalDate().equals(newEnd.toLocalDate())) {</span>
<span class="nc" id="L66">        throw new Exception(&quot;Error: Start Date and End Date should &quot;</span>
            + &quot;not differ for a recurring event.&quot;);
      }
<span class="fc" id="L69">      String newSeriesId = null;</span>
<span class="pc bpc" id="L70" title="1 of 4 branches missed.">      if (sourceEvent.getSeriesId() != null &amp;&amp; !sourceEvent.getSeriesId().isEmpty()) {</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">        if (!seriesIdMapping.containsKey(sourceEvent.getSeriesId())) {</span>
<span class="fc" id="L72">          seriesIdMapping.put(sourceEvent.getSeriesId(), UUID.randomUUID().toString());</span>
        }
<span class="fc" id="L74">        newSeriesId = seriesIdMapping.get(sourceEvent.getSeriesId());</span>
      }
<span class="fc" id="L76">      Event newEvent = new EventBuilder()</span>
<span class="fc" id="L77">          .setSubject(sourceEvent.getSubject())</span>
<span class="fc" id="L78">          .setStartDateTime(newStart)</span>
<span class="fc" id="L79">          .setEndDateTime(newEnd)</span>
<span class="fc" id="L80">          .setLocation(sourceEvent.getLocation())</span>
<span class="fc" id="L81">          .setDescription(sourceEvent.getDescription())</span>
<span class="fc" id="L82">          .setStatus(sourceEvent.getStatus())</span>
<span class="fc" id="L83">          .setSeriesId(newSeriesId)</span>
<span class="fc" id="L84">          .build();</span>
<span class="fc" id="L85">      validateNoDuplicate(newEvent, targetCalendar.getEvents(), newEvents, eventsToRemove);</span>
<span class="fc" id="L86">      newEvents.add(newEvent);</span>
<span class="fc" id="L87">    }</span>
<span class="fc" id="L88">    Set&lt;Event&gt; updatedEvents = new HashSet&lt;&gt;(targetCalendar.getEvents());</span>
<span class="fc" id="L89">    updatedEvents.addAll(newEvents);</span>
<span class="fc" id="L90">    return updatedEvents;</span>
  }

  /**
   * Subclasses implement this to specify which events should be copied
   * based on date criteria.
   */
  protected abstract List&lt;Event&gt; getEventsInDateRange(CopyEventDto dto,
                                                      Calendar sourceCalendar)
      throws Exception;

  /**
   * Subclasses implement this to calculate the target date.
   * Some subclasses may adjust for weekday matching, others use the date as-is.
   *
   * @param dto the copy data transfer object
   * @param firstEventDate the date of the first event being copied
   * @return the calculated target date (possibly adjusted)
   */
  protected abstract LocalDate calculateTargetDate(CopyEventDto dto, LocalDate firstEventDate)
      throws Exception;

  /**
   * Subclasses implement this to provide an appropriate error message.
   */
  protected abstract String getNoEventsFoundMessage(CopyEventDto dto);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>